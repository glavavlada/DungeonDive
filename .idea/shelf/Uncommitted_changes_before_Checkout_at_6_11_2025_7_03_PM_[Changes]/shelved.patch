Index: Program/src/main/View/screen/CombatScreen.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main.View.screen;\r\n\r\nimport javafx.animation.*;\r\nimport javafx.beans.binding.Bindings;\r\nimport javafx.beans.binding.NumberBinding;\r\nimport javafx.geometry.Insets;\r\nimport javafx.geometry.Pos;\r\nimport javafx.scene.Group;\r\nimport javafx.scene.Scene;\r\nimport javafx.scene.control.Button;\r\nimport javafx.scene.control.Label;\r\nimport javafx.scene.control.ProgressBar;\r\nimport javafx.scene.control.ScrollPane;\r\nimport javafx.scene.effect.Bloom;\r\nimport javafx.scene.image.Image;\r\nimport javafx.scene.image.ImageView;\r\nimport javafx.scene.layout.*;\r\nimport javafx.scene.paint.Color;\r\nimport javafx.scene.shape.Ellipse;\r\nimport javafx.scene.text.Font;\r\nimport javafx.scene.text.FontWeight;\r\nimport javafx.scene.text.Text;\r\nimport javafx.stage.Stage;\r\nimport javafx.util.Duration;\r\nimport main.Controller.Controller;\r\nimport main.Model.character.Hero;\r\nimport main.Model.character.Monster;\r\nimport main.Model.dungeon.Room;\r\nimport main.View.GameUI;\r\nimport main.Controller.StateController.GameState;\r\n\r\nimport java.util.List;\r\nimport java.util.Objects;\r\n\r\npublic class CombatScreen extends Screen {\r\n\r\n    // ====== RESPONSIVE CONFIGURATION CONSTANTS ======\r\n    private static final double BASE_WIDTH = 800.0;\r\n    private static final double BASE_HEIGHT = 600.0;\r\n    private static final double MIN_SCALE = 0.6;\r\n    private static final double MAX_SCALE = 2.5;\r\n    private static final double BATTLEFIELD_HEIGHT_RATIO = 0.58;\r\n    private static final double INTERFACE_HEIGHT_RATIO = 0.42;\r\n    private static final double MESSAGE_HEIGHT_RATIO = 0.20;\r\n    private static final double HERO_SPRITE_SIZE_RATIO = 0.15;\r\n    private static final double MONSTER_SPRITE_SIZE_RATIO = 0.175;\r\n    private static final double HERO_SPRITE_MIN_SIZE = 80.0;\r\n    private static final double HERO_SPRITE_MAX_SIZE = 160.0;\r\n    private static final double MONSTER_SPRITE_MIN_SIZE = 90.0;\r\n    private static final double MONSTER_SPRITE_MAX_SIZE = 180.0;\r\n    private static final double HEALTH_BAR_WIDTH_RATIO = 0.15;\r\n    private static final double HEALTH_BAR_HEIGHT_RATIO = 0.016;\r\n    private static final double HEALTH_BAR_MIN_WIDTH = 80.0;\r\n    private static final double HEALTH_BAR_MAX_WIDTH = 180.0;\r\n    private static final double HEALTH_BAR_MIN_HEIGHT = 8.0;\r\n    private static final double HEALTH_BAR_MAX_HEIGHT = 20.0;\r\n    private static final double NAME_FONT_SIZE_RATIO = 0.032;\r\n    private static final double SUBTITLE_FONT_SIZE_RATIO = 0.022;\r\n    private static final double BUTTON_FONT_SIZE_RATIO = 0.028;\r\n    private static final double MESSAGE_FONT_SIZE_RATIO = 0.02;\r\n    private static final double PADDING_RATIO = 0.025;\r\n    private static final double SPACING_RATIO = 0.035;\r\n    private static final double HERO_SPACING_RATIO = 0.26;\r\n    private static final double BUTTON_WIDTH_RATIO = 0.16;\r\n    private static final double BUTTON_HEIGHT_RATIO = 0.08;\r\n    private static final double BUTTON_MIN_WIDTH = 80.0;\r\n    private static final double BUTTON_MAX_WIDTH = 140.0;\r\n    private static final double BUTTON_MIN_HEIGHT = 40.0;\r\n    private static final double BUTTON_MAX_HEIGHT = 80.0;\r\n    private static final double PLATFORM_RADIUS_X_RATIO = 0.11;\r\n    private static final double PLATFORM_RADIUS_Y_RATIO = 0.075;\r\n    private static final double PLATFORM_MIN_RADIUS_X = 60.0;\r\n    private static final double PLATFORM_MAX_RADIUS_X = 120.0;\r\n    private static final double PLATFORM_MIN_RADIUS_Y = 35.0;\r\n    private static final double PLATFORM_MAX_RADIUS_Y = 70.0;\r\n    private static final int MAX_MESSAGES = 6;\r\n    private static final Duration ENTRANCE_DURATION = Duration.seconds(1);\r\n    private static final Duration ATTACK_DURATION = Duration.millis(500);\r\n    private static final Duration SPECIAL_DURATION = Duration.millis(600);\r\n    private static final Duration FLASH_DURATION = Duration.millis(100);\r\n    private static final Duration TURN_DELAY = Duration.seconds(1.5);\r\n    private static final Duration END_DELAY = Duration.seconds(3);\r\n\r\n    // ====== UI COMPONENTS ======\r\n    private VBox battlefield;\r\n    private VBox bottomInterface;\r\n    private ImageView heroSprite;\r\n    private ImageView monsterSprite;\r\n    private ProgressBar heroHealthBar;\r\n    private ProgressBar monsterHealthBar;\r\n    private Label heroHealthNumbers;\r\n    private Label monsterHealthNumbers;\r\n    private Text heroNameDisplay;\r\n    private Text monsterNameDisplay;\r\n    private VBox combatMessages;\r\n\r\n    // ====== COMBAT STATE ======\r\n    private Hero currentHero;\r\n    private Monster currentMonster;\r\n    private boolean playerTurn = true;\r\n    private boolean combatActive = true;\r\n\r\n    // ====== RESPONSIVE BINDINGS ======\r\n    private Scene scene;\r\n    private NumberBinding scaleBinding;\r\n    private NumberBinding paddingBinding;\r\n    private NumberBinding spacingBinding;\r\n    private NumberBinding heroSpriteBinding;\r\n    private NumberBinding monsterSpriteBinding;\r\n    private NumberBinding healthBarWidthBinding;\r\n    private NumberBinding healthBarHeightBinding;\r\n    private NumberBinding nameFontSizeBinding;\r\n    private NumberBinding subtitleFontSizeBinding;\r\n    private NumberBinding buttonFontSizeBinding;\r\n    private NumberBinding messageFontSizeBinding;\r\n    private NumberBinding buttonWidthBinding;\r\n    private NumberBinding buttonHeightBinding;\r\n    private NumberBinding platformRadiusXBinding;\r\n    private NumberBinding platformRadiusYBinding;\r\n    private NumberBinding battlefieldHeightBinding;\r\n    private NumberBinding interfaceHeightBinding;\r\n    private NumberBinding messageHeightBinding;\r\n    private NumberBinding heroSpacingBinding;\r\n\r\n\r\n    public CombatScreen(final Stage thePrimaryStage, final Controller theController) {\r\n        super(thePrimaryStage, theController);\r\n    }\r\n\r\n    @Override\r\n    public void showScreen(GameUI theUI) {\r\n        showScreen(theUI, null);\r\n    }\r\n\r\n    public void showScreen(GameUI theUI, List<Monster> monsters) {\r\n        initializeCombatData();\r\n\r\n        // 1. Create root layout shell first.\r\n        BorderPane root = new BorderPane();\r\n        root.getStyleClass().add(\"combat-root\");\r\n\r\n        // Get the stage and determine initial dimensions from the previous scene.\r\n        Stage currentStage = getStage();\r\n        double width = currentStage.getScene() != null ?\r\n                currentStage.getScene().getWidth() : BASE_WIDTH;\r\n        double height = currentStage.getScene() != null ?\r\n                currentStage.getScene().getHeight() : BASE_HEIGHT;\r\n\r\n        // 2. Create the Scene with the preserved dimensions.\r\n        scene = new Scene(root, width, height);\r\n\r\n        // 3. NOW create bindings, since `scene` exists.\r\n        createBindings();\r\n\r\n        // 4. NOW create the UI content, since bindings exist.\r\n        battlefield = createBattlefield();\r\n        bottomInterface = createBottomInterface();\r\n\r\n        // 5. Add the fully created content to the root.\r\n        root.setTop(battlefield);\r\n        root.setBottom(bottomInterface);\r\n\r\n        // Continue with setup\r\n        setupCSS(scene);\r\n        setupStage(scene);\r\n        setupResponsiveBindings();\r\n\r\n        playEntranceAnimation(\r\n                heroSprite,\r\n                monsterSprite,\r\n                this::addWelcomeMessages\r\n        );\r\n    }\r\n\r\n    private void createBindings() {\r\n        // This method is now safe to call, as `scene` is initialized.\r\n        scaleBinding = Bindings.createDoubleBinding(() -> {\r\n            double widthScale = scene.getWidth() / BASE_WIDTH;\r\n            double heightScale = scene.getHeight() / BASE_HEIGHT;\r\n            double scale = Math.min(widthScale, heightScale);\r\n            return Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale));\r\n        }, scene.widthProperty(), scene.heightProperty());\r\n\r\n        paddingBinding = Bindings.createDoubleBinding(() ->\r\n                        Math.max(10.0, Math.min(scene.getWidth(), scene.getHeight()) * PADDING_RATIO),\r\n                scene.widthProperty(), scene.heightProperty());\r\n\r\n        spacingBinding = Bindings.createDoubleBinding(() ->\r\n                        Math.max(15.0, Math.min(scene.getWidth(), scene.getHeight()) * SPACING_RATIO),\r\n                scene.widthProperty(), scene.heightProperty());\r\n\r\n        heroSpacingBinding = Bindings.createDoubleBinding(() ->\r\n                        Math.max(150.0, scene.getWidth() * HERO_SPACING_RATIO),\r\n                scene.widthProperty());\r\n\r\n        battlefieldHeightBinding = Bindings.createDoubleBinding(() ->\r\n                        scene.getHeight() * BATTLEFIELD_HEIGHT_RATIO,\r\n                scene.heightProperty());\r\n\r\n        interfaceHeightBinding = Bindings.createDoubleBinding(() ->\r\n                        scene.getHeight() * INTERFACE_HEIGHT_RATIO,\r\n                scene.heightProperty());\r\n\r\n        messageHeightBinding = Bindings.createDoubleBinding(() ->\r\n                        scene.getHeight() * MESSAGE_HEIGHT_RATIO,\r\n                scene.heightProperty());\r\n\r\n        heroSpriteBinding = Bindings.createDoubleBinding(() -> {\r\n            double calculated = scene.getWidth() * HERO_SPRITE_SIZE_RATIO;\r\n            return Math.max(HERO_SPRITE_MIN_SIZE, Math.min(HERO_SPRITE_MAX_SIZE, calculated));\r\n        }, scene.widthProperty());\r\n\r\n        monsterSpriteBinding = Bindings.createDoubleBinding(() -> {\r\n            double calculated = scene.getWidth() * MONSTER_SPRITE_SIZE_RATIO;\r\n            return Math.max(MONSTER_SPRITE_MIN_SIZE, Math.min(MONSTER_SPRITE_MAX_SIZE, calculated));\r\n        }, scene.widthProperty());\r\n\r\n        healthBarWidthBinding = Bindings.createDoubleBinding(() -> {\r\n            double calculated = scene.getWidth() * HEALTH_BAR_WIDTH_RATIO;\r\n            return Math.max(HEALTH_BAR_MIN_WIDTH, Math.min(HEALTH_BAR_MAX_WIDTH, calculated));\r\n        }, scene.widthProperty());\r\n\r\n        healthBarHeightBinding = Bindings.createDoubleBinding(() -> {\r\n            double calculated = scene.getHeight() * HEALTH_BAR_HEIGHT_RATIO;\r\n            return Math.max(HEALTH_BAR_MIN_HEIGHT, Math.min(HEALTH_BAR_MAX_HEIGHT, calculated));\r\n        }, scene.heightProperty());\r\n\r\n        nameFontSizeBinding = Bindings.createDoubleBinding(() ->\r\n                        Math.max(14.0, scene.getHeight() * NAME_FONT_SIZE_RATIO),\r\n                scene.heightProperty());\r\n\r\n        subtitleFontSizeBinding = Bindings.createDoubleBinding(() ->\r\n                        Math.max(10.0, scene.getHeight() * SUBTITLE_FONT_SIZE_RATIO),\r\n                scene.heightProperty());\r\n\r\n        buttonFontSizeBinding = Bindings.createDoubleBinding(() ->\r\n                        Math.max(12.0, scene.getHeight() * BUTTON_FONT_SIZE_RATIO),\r\n                scene.heightProperty());\r\n\r\n        messageFontSizeBinding = Bindings.createDoubleBinding(() ->\r\n                        Math.max(11.0, scene.getHeight() * MESSAGE_FONT_SIZE_RATIO),\r\n                scene.heightProperty());\r\n\r\n        buttonWidthBinding = Bindings.createDoubleBinding(() -> {\r\n            double calculated = scene.getWidth() * BUTTON_WIDTH_RATIO;\r\n            return Math.max(BUTTON_MIN_WIDTH, Math.min(BUTTON_MAX_WIDTH, calculated));\r\n        }, scene.widthProperty());\r\n\r\n        buttonHeightBinding = Bindings.createDoubleBinding(() -> {\r\n            double calculated = scene.getHeight() * BUTTON_HEIGHT_RATIO;\r\n            return Math.max(BUTTON_MIN_HEIGHT, Math.min(BUTTON_MAX_HEIGHT, calculated));\r\n        }, scene.heightProperty());\r\n\r\n        platformRadiusXBinding = Bindings.createDoubleBinding(() -> {\r\n            double calculated = scene.getWidth() * PLATFORM_RADIUS_X_RATIO;\r\n            return Math.max(PLATFORM_MIN_RADIUS_X, Math.min(PLATFORM_MAX_RADIUS_X, calculated));\r\n        }, scene.widthProperty());\r\n\r\n        platformRadiusYBinding = Bindings.createDoubleBinding(() -> {\r\n            double calculated = scene.getHeight() * PLATFORM_RADIUS_Y_RATIO;\r\n            return Math.max(PLATFORM_MIN_RADIUS_Y, Math.min(PLATFORM_MAX_RADIUS_Y, calculated));\r\n        }, scene.heightProperty());\r\n    }\r\n\r\n    private void setupResponsiveBindings() {\r\n        // Bind layout container sizes\r\n        battlefield.prefHeightProperty().bind(battlefieldHeightBinding);\r\n        bottomInterface.prefHeightProperty().bind(interfaceHeightBinding);\r\n\r\n        // Bind sprite sizes now, as they are part of the layout\r\n        heroSprite.fitWidthProperty().bind(heroSpriteBinding);\r\n        heroSprite.fitHeightProperty().bind(heroSpriteBinding);\r\n        monsterSprite.fitWidthProperty().bind(monsterSpriteBinding);\r\n        monsterSprite.fitHeightProperty().bind(monsterSpriteBinding);\r\n\r\n        // Update platforms when sprite properties change\r\n        heroSprite.layoutXProperty().addListener((obs, oldVal, newVal) -> updatePlatformPositions());\r\n        heroSprite.layoutYProperty().addListener((obs, oldVal, newVal) -> updatePlatformPositions());\r\n        heroSprite.translateXProperty().addListener((obs, oldVal, newVal) -> updatePlatformPositions());\r\n        heroSprite.translateYProperty().addListener((obs, oldVal, newVal) -> updatePlatformPositions());\r\n        monsterSprite.layoutXProperty().addListener((obs, oldVal, newVal) -> updatePlatformPositions());\r\n        monsterSprite.layoutYProperty().addListener((obs, oldVal, newVal) -> updatePlatformPositions());\r\n        monsterSprite.translateXProperty().addListener((obs, oldVal, newVal) -> updatePlatformPositions());\r\n        monsterSprite.translateYProperty().addListener((obs, oldVal, newVal) -> updatePlatformPositions());\r\n\r\n        // Now create platforms since responsive bindings are available\r\n        createBattlePlatforms();\r\n\r\n        // Update platform positions when scene size changes\r\n        scene.widthProperty().addListener((obs, oldVal, newVal) -> updatePlatformPositions());\r\n        scene.heightProperty().addListener((obs, oldVal, newVal) -> updatePlatformPositions());\r\n    }\r\n\r\n    private void updatePlatformPositions() {\r\n        if (battlefield != null && heroSprite != null && monsterSprite != null) {\r\n            // Delay the platform update to ensure layout has been calculated\r\n            javafx.application.Platform.runLater(this::createBattlePlatforms);\r\n        }\r\n    }\r\n\r\n    private void initializeCombatData() {\r\n        currentHero = getController().getPlayer();\r\n        if (currentHero != null) {\r\n            Room currentRoom = getController().getDungeon().getRoom(currentHero.getPosition());\r\n            List<Monster> monsters = currentRoom.getMonsters();\r\n            currentMonster = monsters.isEmpty() ? null : monsters.getFirst();\r\n        }\r\n        resetCombat();\r\n    }\r\n\r\n    private VBox createBattlefield() {\r\n        VBox vBox = new VBox();\r\n        vBox.getStyleClass().add(\"battlefield\");\r\n\r\n        HBox battleArea = new HBox();\r\n        battleArea.setAlignment(Pos.CENTER);\r\n\r\n        // This is safe now because createBindings() was called before this method.\r\n        battleArea.paddingProperty().bind(Bindings.createObjectBinding(() ->\r\n                        new Insets(paddingBinding.getValue().doubleValue()),\r\n                paddingBinding));\r\n        battleArea.spacingProperty().bind(heroSpacingBinding);\r\n\r\n        VBox heroSide = createHeroSide();\r\n        VBox monsterSide = createMonsterSide();\r\n\r\n        heroSide.translateYProperty().bind(paddingBinding.multiply(-0.5));\r\n        heroSide.translateXProperty().bind(paddingBinding.multiply(-1.5));\r\n        monsterSide.translateYProperty().bind(paddingBinding.multiply(-2));\r\n        monsterSide.translateXProperty().bind(paddingBinding.multiply(-2));\r\n\r\n        battleArea.getChildren().addAll(heroSide, monsterSide);\r\n        vBox.getChildren().add(battleArea);\r\n\r\n        return vBox;\r\n    }\r\n\r\n    private VBox createHeroSide() {\r\n        VBox heroSide = new VBox();\r\n        heroSide.setAlignment(Pos.CENTER);\r\n        heroSide.spacingProperty().bind(spacingBinding.divide(2));\r\n\r\n        heroSprite = createHeroSprite(currentHero);\r\n        HBox heroInfo = createHeroInfo();\r\n\r\n        heroSide.getChildren().addAll(heroInfo, heroSprite);\r\n        return heroSide;\r\n    }\r\n\r\n    private HBox createHeroInfo() {\r\n        HBox heroInfo = new HBox();\r\n        heroInfo.getStyleClass().add(\"combat-info-panel\");\r\n        heroInfo.setAlignment(Pos.CENTER_RIGHT);\r\n        heroInfo.spacingProperty().bind(spacingBinding.divide(2));\r\n\r\n        VBox nameSection = createNameSection(true);\r\n        VBox healthSection = createHealthSection(true);\r\n\r\n        heroInfo.getChildren().addAll(nameSection, healthSection);\r\n        return heroInfo;\r\n    }\r\n\r\n    private VBox createMonsterSide() {\r\n        VBox monsterSide = new VBox();\r\n        monsterSide.setAlignment(Pos.CENTER_RIGHT);\r\n        monsterSide.spacingProperty().bind(spacingBinding.divide(2));\r\n\r\n\r\n        monsterSprite = createMonsterSprite(currentMonster);\r\n        HBox monsterInfo = createMonsterInfo();\r\n\r\n        monsterSide.getChildren().addAll(monsterInfo, monsterSprite);\r\n        return monsterSide;\r\n    }\r\n\r\n    private HBox createMonsterInfo() {\r\n        HBox monsterInfo = new HBox();\r\n        monsterInfo.getStyleClass().add(\"combat-info-panel\");\r\n        monsterInfo.setAlignment(Pos.CENTER);\r\n\r\n        VBox nameSection = createNameSection(false);\r\n        VBox healthSection = createHealthSection(false);\r\n\r\n        monsterInfo.getChildren().addAll(nameSection, healthSection);\r\n        return monsterInfo;\r\n    }\r\n\r\n    private VBox createNameSection(boolean isHero) {\r\n        VBox nameSection = new VBox();\r\n        nameSection.setAlignment(isHero ? Pos.CENTER_LEFT : Pos.CENTER_RIGHT);\r\n        nameSection.spacingProperty().bind(spacingBinding.divide(6));\r\n\r\n        if (isHero) {\r\n            heroNameDisplay = new Text(getHeroName());\r\n            heroNameDisplay.getStyleClass().add(\"combat-name\");\r\n            // MODIFICATION: Use PixelFont to allow CSS to be overridden by responsive size.\r\n            heroNameDisplay.fontProperty().bind(Bindings.createObjectBinding(() ->\r\n                            Font.font(\"PixelFont\", FontWeight.BOLD, nameFontSizeBinding.getValue().doubleValue()),\r\n                    nameFontSizeBinding));\r\n\r\n            Text classText = new Text(getHeroClass());\r\n            classText.getStyleClass().add(\"combat-subtitle\");\r\n            // MODIFICATION: Use PixelFont\r\n            classText.fontProperty().bind(Bindings.createObjectBinding(() ->\r\n                            Font.font(\"PixelFont\", subtitleFontSizeBinding.getValue().doubleValue()),\r\n                    subtitleFontSizeBinding));\r\n\r\n            nameSection.getChildren().addAll(heroNameDisplay, classText);\r\n        } else {\r\n            monsterNameDisplay = new Text(getMonsterName());\r\n            monsterNameDisplay.getStyleClass().add(\"combat-name\");\r\n            // MODIFICATION: Use PixelFont\r\n            monsterNameDisplay.fontProperty().bind(Bindings.createObjectBinding(() ->\r\n                            Font.font(\"PixelFont\", FontWeight.BOLD, nameFontSizeBinding.getValue().doubleValue()),\r\n                    nameFontSizeBinding));\r\n\r\n            Text levelText = new Text(getMonsterLevel());\r\n            levelText.getStyleClass().add(\"combat-subtitle\");\r\n            // MODIFICATION: Use PixelFont\r\n            levelText.fontProperty().bind(Bindings.createObjectBinding(() ->\r\n                            Font.font(\"PixelFont\", subtitleFontSizeBinding.getValue().doubleValue()),\r\n                    subtitleFontSizeBinding));\r\n\r\n            nameSection.getChildren().addAll(monsterNameDisplay, levelText);\r\n        }\r\n\r\n        return nameSection;\r\n    }\r\n\r\n    private VBox createHealthSection(boolean isHero) {\r\n        VBox healthSection = new VBox();\r\n        healthSection.setAlignment(isHero ? Pos.CENTER_LEFT : Pos.CENTER_RIGHT);\r\n        healthSection.spacingProperty().bind(spacingBinding.divide(6));\r\n\r\n        Label hpLabel = new Label(\"HP\");\r\n        hpLabel.getStyleClass().add(\"combat-subtitle\");\r\n        // MODIFICATION: Use PixelFont\r\n        hpLabel.fontProperty().bind(Bindings.createObjectBinding(() ->\r\n                        Font.font(\"PixelFont\", subtitleFontSizeBinding.getValue().doubleValue()),\r\n                subtitleFontSizeBinding));\r\n\r\n\r\n        ProgressBar healthBar = createHealthBar();\r\n        Label healthNumbers = new Label();\r\n        healthNumbers.getStyleClass().add(\"combat-subtitle\");\r\n        // MODIFICATION: Use PixelFont\r\n        healthNumbers.fontProperty().bind(Bindings.createObjectBinding(() ->\r\n                        Font.font(\"PixelFont\", subtitleFontSizeBinding.getValue().doubleValue()),\r\n                subtitleFontSizeBinding));\r\n\r\n        if (isHero) {\r\n            heroHealthBar = healthBar;\r\n            heroHealthNumbers = healthNumbers;\r\n            updateHeroHealthDisplay();\r\n        } else {\r\n            monsterHealthBar = healthBar;\r\n            monsterHealthNumbers = healthNumbers;\r\n            updateMonsterHealthDisplay();\r\n        }\r\n\r\n        healthSection.getChildren().addAll(hpLabel, healthBar, healthNumbers);\r\n        return healthSection;\r\n    }\r\n\r\n    private ProgressBar createHealthBar() {\r\n        ProgressBar healthBar = new ProgressBar();\r\n        healthBar.getStyleClass().add(\"progress-bar\");\r\n        healthBar.prefWidthProperty().bind(healthBarWidthBinding);\r\n        healthBar.minWidthProperty().bind(healthBarWidthBinding);\r\n        healthBar.prefHeightProperty().bind(healthBarHeightBinding);\r\n        healthBar.minHeightProperty().bind(healthBarHeightBinding);\r\n        return healthBar;\r\n    }\r\n\r\n    private VBox createBottomInterface() {\r\n        VBox bottomInterface = new VBox();\r\n        bottomInterface.getStyleClass().add(\"bottom-interface\");\r\n        bottomInterface.paddingProperty().bind(Bindings.createObjectBinding(() ->\r\n                        new Insets(paddingBinding.getValue().doubleValue()),\r\n                paddingBinding));\r\n\r\n        combatMessages = createMessageArea();\r\n        ScrollPane messageScroll = createMessageScrollPane();\r\n        HBox buttonArea = createButtonArea();\r\n\r\n        bottomInterface.getChildren().addAll(messageScroll, buttonArea);\r\n        return bottomInterface;\r\n    }\r\n\r\n    private VBox createMessageArea() {\r\n        VBox messageArea = new VBox();\r\n        messageArea.getStyleClass().add(\"combat-message-area\");\r\n        messageArea.setAlignment(Pos.BOTTOM_LEFT);\r\n        messageArea.spacingProperty().bind(spacingBinding.divide(4));\r\n        messageArea.prefHeightProperty().bind(messageHeightBinding);\r\n        return messageArea;\r\n    }\r\n\r\n    private ScrollPane createMessageScrollPane() {\r\n        ScrollPane messageScroll = new ScrollPane(combatMessages);\r\n        messageScroll.setFitToWidth(true);\r\n        messageScroll.setVbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED);\r\n        messageScroll.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);\r\n        messageScroll.setStyle(\"-fx-background-color: transparent;\");\r\n        return messageScroll;\r\n    }\r\n\r\n    private HBox createButtonArea() {\r\n        HBox buttonBox = new HBox();\r\n        buttonBox.setAlignment(Pos.CENTER);\r\n        buttonBox.spacingProperty().bind(spacingBinding);\r\n        buttonBox.paddingProperty().bind(Bindings.createObjectBinding(() ->\r\n                        new Insets(paddingBinding.getValue().doubleValue(), 0, 0, 0),\r\n                paddingBinding));\r\n\r\n        Button attackBtn = createCombatButton(\"ATTACK\", \"attack-button\", this::performPlayerAttack);\r\n        Button specialBtn = createCombatButton(getSpecialAttackName(), \"special-button\", this::performSpecialAttack);\r\n        Button itemBtn = createCombatButton(\"ITEM\", \"item-button\", this::openInventory);\r\n        Button runBtn = createCombatButton(\"RUN\", \"run-button\", this::attemptRun);\r\n\r\n        buttonBox.getChildren().addAll(attackBtn, specialBtn, itemBtn, runBtn);\r\n        return buttonBox;\r\n    }\r\n\r\n    private Button createCombatButton(String text, String styleClass, Runnable action) {\r\n        Button button = new Button(text);\r\n        button.getStyleClass().addAll(\"combat-button\", styleClass);\r\n\r\n        // MODIFICATION: Use PixelFont\r\n        button.fontProperty().bind(Bindings.createObjectBinding(() ->\r\n                        Font.font(\"PixelFont\", FontWeight.BOLD, buttonFontSizeBinding.getValue().doubleValue()),\r\n                buttonFontSizeBinding));\r\n\r\n        button.minWidthProperty().bind(buttonWidthBinding);\r\n        button.setMaxWidth(Double.MAX_VALUE);\r\n\r\n        button.prefHeightProperty().bind(buttonHeightBinding);\r\n\r\n        button.setOnAction(_ -> {\r\n            if (playerTurn && combatActive) {\r\n                action.run();\r\n            }\r\n        });\r\n\r\n        HBox.setHgrow(button, Priority.ALWAYS);\r\n\r\n        return button;\r\n    }\r\n\r\n    // Combat Actions\r\n    private void performPlayerAttack() {\r\n        if (canPlayerAct()) return;\r\n\r\n        final Monster attackedMonster = currentMonster;\r\n        startPlayerTurn();\r\n        updateTurnIndicator();\r\n        addCombatMessage(currentHero.getName() + \" uses Attack!\");\r\n\r\n        playAttackAnimation(heroSprite, monsterSprite, () -> {\r\n            getController().getGameController().playerAttack();\r\n            updateCombatDisplay();\r\n            handlePostAttack(attackedMonster);\r\n        });\r\n    }\r\n\r\n    private void performSpecialAttack() {\r\n        if (canPlayerAct()) return;\r\n\r\n        if (!currentHero.canUseSpecialAttack()) {\r\n            addCombatMessage(\"Cannot use special attack right now!\");\r\n            return;\r\n        }\r\n\r\n        final Monster attackedMonster = currentMonster;\r\n        startPlayerTurn();\r\n        updateTurnIndicator();\r\n        addCombatMessage(currentHero.getName() + \" uses \" +\r\n                currentHero.getType().getSpecialAttackName() + \"!\");\r\n\r\n        playSpecialAttackAnimation(heroSprite, monsterSprite, () -> {\r\n            getController().getGameController().playerSpecialAttack();\r\n            updateCombatDisplay();\r\n            handlePostAttack(attackedMonster);\r\n        });\r\n    }\r\n\r\n    private void openInventory() {\r\n        addCombatMessage(\"Item menu - opening inventory...\");\r\n        getController().getGameController().openInventory();\r\n    }\r\n\r\n    private void attemptRun() {\r\n        addCombatMessage(currentHero.getName() + \" tries to run away!\");\r\n        getController().getGameController().playerRun();\r\n    }\r\n\r\n    private void handlePostAttack(Monster attackedMonster) {\r\n        refreshMonsterState();\r\n\r\n        if (currentMonster != null && currentMonster.isAlive()) {\r\n            Timeline delay = new Timeline(new KeyFrame(TURN_DELAY, _ -> performMonsterTurn()));\r\n            delay.play();\r\n        } else {\r\n            endCombat(true, attackedMonster);\r\n        }\r\n    }\r\n\r\n    private void performMonsterTurn() {\r\n        if (!combatActive || currentMonster == null) return;\r\n\r\n        addCombatMessage(currentMonster.getName() + \" attacks!\");\r\n\r\n        playMonsterAttackAnimation(monsterSprite, heroSprite, () -> {\r\n            getController().getGameController().monsterAttacks();\r\n            boolean isGameOver = getController().getGameController().getStateController().isInState(GameState.GAME_OVER);\r\n\r\n            if (isGameOver) {\r\n                endCombat(false);\r\n            } else if (combatActive) {\r\n                startMonsterTurn();\r\n                updateTurnIndicator();\r\n            }\r\n        });\r\n    }\r\n\r\n    // UI Updates\r\n    public void updateCombatDisplay() {\r\n        updateCombatStats();\r\n        updateHealthBars();\r\n    }\r\n\r\n    private void updateCombatStats() {\r\n        if (currentHero != null) {\r\n            heroNameDisplay.setText(currentHero.getName());\r\n            updateHeroHealthDisplay();\r\n        }\r\n\r\n        if (currentMonster != null) {\r\n            monsterNameDisplay.setText(currentMonster.getName());\r\n            updateMonsterHealthDisplay();\r\n        }\r\n    }\r\n\r\n    private void updateHealthBars() {\r\n        if (currentHero != null) {\r\n            double heroHealthRatio = currentHero.getHealthPercentage();\r\n            animateHealthBar(heroHealthBar, heroHealthRatio);\r\n            updateHealthBarColor(heroHealthBar, heroHealthRatio);\r\n        }\r\n\r\n        if (currentMonster != null) {\r\n            double monsterHealthRatio = currentMonster.getHealthPercentage();\r\n            animateHealthBar(monsterHealthBar, monsterHealthRatio);\r\n            updateHealthBarColor(monsterHealthBar, monsterHealthRatio);\r\n        }\r\n    }\r\n\r\n    private void animateHealthBar(ProgressBar healthBar, double targetRatio) {\r\n        Timeline healthAnimation = new Timeline(\r\n                new KeyFrame(Duration.seconds(0.8), new KeyValue(healthBar.progressProperty(), targetRatio))\r\n        );\r\n        healthAnimation.play();\r\n    }\r\n\r\n    private void updateHealthBarColor(ProgressBar healthBar, double ratio) {\r\n        healthBar.getStyleClass().removeAll(\"health-bar-green\", \"health-bar-orange\", \"health-bar-red\");\r\n\r\n        String colorClass = ratio > 0.6 ? \"health-bar-green\" :\r\n                ratio > 0.3 ? \"health-bar-orange\" : \"health-bar-red\";\r\n        healthBar.getStyleClass().add(colorClass);\r\n    }\r\n\r\n    private void updateHeroHealthDisplay() {\r\n        if (currentHero != null && heroHealthNumbers != null) {\r\n            heroHealthNumbers.setText(currentHero.getHealthDisplay());\r\n            updateHealthBarColor(heroHealthBar, currentHero.getHealthPercentage());\r\n        }\r\n    }\r\n\r\n    private void updateMonsterHealthDisplay() {\r\n        if (currentMonster != null && monsterHealthNumbers != null) {\r\n            monsterHealthNumbers.setText(currentMonster.getHealthDisplay());\r\n            updateHealthBarColor(monsterHealthBar, currentMonster.getHealthPercentage());\r\n        }\r\n    }\r\n\r\n    private void updateTurnIndicator() {\r\n        if (playerTurn) {\r\n            heroSprite.setEffect(new javafx.scene.effect.DropShadow(10, Color.CYAN));\r\n            monsterSprite.setEffect(null);\r\n        } else {\r\n            monsterSprite.setEffect(new javafx.scene.effect.DropShadow(10, Color.RED));\r\n            heroSprite.setEffect(null);\r\n        }\r\n    }\r\n\r\n    // Combat End\r\n    private void endCombat(boolean victory) {\r\n        endCombat(victory, currentMonster);\r\n    }\r\n\r\n    private void endCombat(boolean victory, Monster monsterForMessage) {\r\n        endCombat();\r\n\r\n        if (victory) {\r\n            handleVictory(monsterForMessage);\r\n        } else {\r\n            handleDefeat();\r\n        }\r\n    }\r\n\r\n    private void handleVictory(Monster monsterForMessage) {\r\n        String monsterName = (monsterForMessage != null) ? monsterForMessage.getName() : \"The monster\";\r\n        addCombatMessage(monsterName + \" was defeated!\");\r\n        addCombatMessage(currentHero.getName() + \" wins the battle!\");\r\n\r\n        playVictoryAnimation(heroSprite);\r\n\r\n        Timeline endDelay = new Timeline(new KeyFrame(END_DELAY, _ ->\r\n                getController().resumeCurrentGame(getController().getGameController().getGameUI())\r\n        ));\r\n        endDelay.play();\r\n    }\r\n\r\n    private void handleDefeat() {\r\n        addCombatMessage(currentHero.getName() + \" was defeated!\");\r\n        addCombatMessage(\"Game Over!\");\r\n        playDefeatAnimation(heroSprite);\r\n    }\r\n\r\n    // Message System\r\n    private void addCombatMessage(String message) {\r\n        Label messageLabel = new Label(message);\r\n        messageLabel.getStyleClass().add(\"combat-message\");\r\n        messageLabel.setWrapText(true);\r\n        // MODIFICATION: Use PixelFont\r\n        messageLabel.fontProperty().bind(Bindings.createObjectBinding(() ->\r\n                        Font.font(\"PixelFont\", messageFontSizeBinding.getValue().doubleValue()),\r\n                messageFontSizeBinding));\r\n        messageLabel.maxWidthProperty().bind(scene.widthProperty().multiply(0.85));\r\n\r\n        combatMessages.getChildren().add(messageLabel);\r\n\r\n        if (combatMessages.getChildren().size() > MAX_MESSAGES) {\r\n            combatMessages.getChildren().removeFirst();\r\n        }\r\n\r\n        animateTyping(messageLabel, message);\r\n    }\r\n\r\n    private void animateTyping(Label label, String fullText) {\r\n        Timeline typing = new Timeline();\r\n        label.setText(\"\");\r\n\r\n        for (int i = 0; i <= fullText.length(); i++) {\r\n            final int index = i;\r\n            typing.getKeyFrames().add(\r\n                    new KeyFrame(Duration.millis(index * 25), _ -> label.setText(fullText.substring(0, index)))\r\n            );\r\n        }\r\n        typing.play();\r\n    }\r\n\r\n    private void createBattlePlatforms() {\r\n        if (battlefield == null || heroSprite == null || monsterSprite == null) return;\r\n\r\n        battlefield.getChildren().removeIf(node ->\r\n                node.getUserData() != null && node.getUserData().equals(\"platform-layer\"));\r\n\r\n        Pane platformLayer = new Pane();\r\n        platformLayer.setUserData(\"platform-layer\");\r\n        platformLayer.setMouseTransparent(true);\r\n\r\n        // Use bounds to get actual positions in the battlefield coordinate space\r\n        var heroBounds = battlefield.sceneToLocal(heroSprite.localToScene(heroSprite.getBoundsInLocal()));\r\n        var monsterBounds = battlefield.sceneToLocal(monsterSprite.localToScene(monsterSprite.getBoundsInLocal()));\r\n\r\n        // Calculate platform positions - use the exact center of the sprites\r\n        double heroPlatformX = heroBounds.getCenterX();\r\n        double heroPlatformY = heroBounds.getCenterY() + (heroBounds.getHeight() / 4); // Center + half height + offset\r\n\r\n        double monsterPlatformX = monsterBounds.getCenterX();\r\n        double monsterPlatformY = monsterBounds.getCenterY() + (monsterBounds.getHeight() / 4); // Center + half height + offset\r\n        double radiusX = platformRadiusXBinding.getValue().doubleValue();\r\n        double radiusY = platformRadiusYBinding.getValue().doubleValue();\r\n\r\n        Group heroPlatform = createPlatform(\r\n                heroPlatformX, heroPlatformY, radiusX * 0.9, radiusY);\r\n        Group monsterPlatform = createPlatform(\r\n                monsterPlatformX, monsterPlatformY, radiusX, radiusY * 1.1);\r\n\r\n        platformLayer.getChildren().addAll(heroPlatform, monsterPlatform);\r\n        platformLayer.prefHeightProperty().bind(battlefieldHeightBinding);\r\n        battlefield.getChildren().addFirst(platformLayer);\r\n    }\r\n\r\n    // Setup Methods\r\n    private void setupCSS(Scene scene) {\r\n        try {\r\n            String cssPath = \"/main/View/css/combat.css\";\r\n            var cssUrl = getClass().getResource(cssPath);\r\n            if (cssUrl != null) {\r\n                scene.getStylesheets().add(cssUrl.toExternalForm());\r\n            } else {\r\n                System.err.println(\"Could not find combat.css at: \" + cssPath);\r\n            }\r\n        } catch (Exception e) {\r\n            System.err.println(\"Could not load combat.css: \" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    private void setupStage(Scene scene) {\r\n        // Preserve the full-screen state from the previous screen.\r\n        Stage currentStage = getStage();\r\n        boolean wasFullScreen = currentStage.isFullScreen();\r\n\r\n        currentStage.setScene(scene);\r\n        currentStage.setTitle(\"Combat - \" + getHeroName() + \" vs \" + getMonsterName());\r\n\r\n        // Re-apply full-screen if it was active, as setScene() can exit it.\r\n        if (wasFullScreen) {\r\n            currentStage.setFullScreen(true);\r\n        }\r\n\r\n        // Show the stage if it isn't already visible.\r\n        if (!currentStage.isShowing()) {\r\n            currentStage.show();\r\n        }\r\n    }\r\n\r\n    private void addWelcomeMessages() {\r\n        addCombatMessage(\"A wild \" + getMonsterName() + \" appeared!\");\r\n        addCombatMessage(\"What will \" + getHeroName() + \" do?\");\r\n    }\r\n\r\n    // Utility Methods\r\n    private boolean canPlayerAct() {\r\n        return !playerTurn || !combatActive || currentMonster == null;\r\n    }\r\n\r\n    private void refreshMonsterState() {\r\n        Room currentRoom = getController().getDungeon().getRoom(currentHero.getPosition());\r\n        List<Monster> monsters = currentRoom.getMonsters();\r\n        currentMonster = monsters.isEmpty() ? null : monsters.getFirst();\r\n    }\r\n\r\n    private String getHeroName() {\r\n        return currentHero != null ? currentHero.getName() : \"Hero\";\r\n    }\r\n\r\n    private String getHeroClass() {\r\n        return currentHero != null ? currentHero.getType().getDisplayName() : \"Unknown\";\r\n    }\r\n\r\n    private String getMonsterName() {\r\n        return currentMonster != null ? currentMonster.getName() : \"Unknown Monster\";\r\n    }\r\n\r\n    private String getMonsterLevel() {\r\n        return \"Lv. \" + (currentMonster != null && currentMonster.isElite() ? \"Elite\" : \"Normal\");\r\n    }\r\n\r\n    private String getSpecialAttackName() {\r\n        return currentHero != null ?\r\n                currentHero.getType().getSpecialAttackName().toUpperCase() : \"SPECIAL\";\r\n    }\r\n\r\n    public boolean isCombatActive() {\r\n        return combatActive;\r\n    }\r\n\r\n    public boolean isPlayerTurn() {\r\n        return playerTurn;\r\n    }\r\n\r\n    // Combat State Management\r\n    private void resetCombat() {\r\n        playerTurn = true;\r\n        combatActive = true;\r\n    }\r\n\r\n    private void startPlayerTurn() {\r\n        playerTurn = false;\r\n    }\r\n\r\n    private void startMonsterTurn() {\r\n        playerTurn = true;\r\n    }\r\n\r\n    private void endCombat() {\r\n        combatActive = false;\r\n        playerTurn = false;\r\n    }\r\n\r\n\r\n    // Animation Methods\r\n    private void playEntranceAnimation(ImageView heroSprite, ImageView monsterSprite, Runnable onComplete) {\r\n        TranslateTransition heroEntrance = new TranslateTransition(ENTRANCE_DURATION, heroSprite);\r\n        heroEntrance.setFromX(-400);\r\n        heroEntrance.setToX(0);\r\n\r\n        TranslateTransition monsterEntrance = new TranslateTransition(ENTRANCE_DURATION, monsterSprite);\r\n        monsterEntrance.setFromX(400);\r\n        monsterEntrance.setToX(0);\r\n\r\n        ParallelTransition entrance = new ParallelTransition(heroEntrance, monsterEntrance);\r\n        entrance.setOnFinished(_ -> onComplete.run());\r\n        entrance.play();\r\n    }\r\n\r\n    private void playAttackAnimation(ImageView attacker, ImageView target, Runnable onComplete) {\r\n        Timeline attack = new Timeline(\r\n                new KeyFrame(Duration.millis(0), new KeyValue(attacker.translateXProperty(), 0)),\r\n                new KeyFrame(Duration.millis(200), new KeyValue(attacker.translateXProperty(), 20)),\r\n                new KeyFrame(Duration.millis(250), new KeyValue(attacker.translateXProperty(), 15)),\r\n                new KeyFrame(Duration.millis(300), new KeyValue(attacker.translateXProperty(), 25)),\r\n                new KeyFrame(Duration.millis(350), new KeyValue(attacker.translateXProperty(), 15)),\r\n                new KeyFrame(ATTACK_DURATION, new KeyValue(attacker.translateXProperty(), 0))\r\n        );\r\n\r\n        attack.setOnFinished(_ -> playFlashEffect(target, onComplete));\r\n        attack.play();\r\n    }\r\n\r\n    private void playSpecialAttackAnimation(ImageView attacker, ImageView target, Runnable onComplete) {\r\n        RotateTransition spin = new RotateTransition(SPECIAL_DURATION, attacker);\r\n        spin.setByAngle(360);\r\n\r\n        ScaleTransition grow = new ScaleTransition(SPECIAL_DURATION, attacker);\r\n        grow.setToX(1.3);\r\n        grow.setToY(1.3);\r\n        grow.setAutoReverse(true);\r\n        grow.setCycleCount(2);\r\n\r\n        ParallelTransition special = new ParallelTransition(spin, grow);\r\n        special.setOnFinished(_ -> playIntenseFlashEffect(target, onComplete));\r\n        special.play();\r\n    }\r\n\r\n    private void playMonsterAttackAnimation(ImageView attacker, ImageView target, Runnable onComplete) {\r\n        Timeline attack = new Timeline(\r\n                new KeyFrame(Duration.millis(0), new KeyValue(attacker.translateXProperty(), 0)),\r\n                new KeyFrame(Duration.millis(300), new KeyValue(attacker.translateXProperty(), -40)),\r\n                new KeyFrame(Duration.millis(600), new KeyValue(attacker.translateXProperty(), 0))\r\n        );\r\n\r\n        attack.setOnFinished(_ -> playFlashEffect(target, onComplete));\r\n        attack.play();\r\n    }\r\n\r\n    private void playVictoryAnimation(ImageView sprite) {\r\n        RotateTransition victory = new RotateTransition(Duration.seconds(1), sprite);\r\n        victory.setByAngle(360);\r\n        victory.play();\r\n    }\r\n\r\n    private void playDefeatAnimation(ImageView sprite) {\r\n        FadeTransition defeat = new FadeTransition(Duration.seconds(1), sprite);\r\n        defeat.setToValue(0.3);\r\n        defeat.play();\r\n    }\r\n\r\n    private void playFlashEffect(ImageView target, Runnable onComplete) {\r\n        FadeTransition flash = new FadeTransition(FLASH_DURATION, target);\r\n        flash.setFromValue(1.0);\r\n        flash.setToValue(0.3);\r\n        flash.setCycleCount(4);\r\n        flash.setAutoReverse(true);\r\n        flash.setOnFinished(_ -> onComplete.run());\r\n        flash.play();\r\n    }\r\n\r\n    private void playIntenseFlashEffect(ImageView target, Runnable onComplete) {\r\n        FadeTransition flash = new FadeTransition(Duration.millis(80), target);\r\n        flash.setFromValue(1.0);\r\n        flash.setToValue(0.1);\r\n        flash.setCycleCount(4);\r\n        flash.setAutoReverse(true);\r\n        flash.setOnFinished(_ -> onComplete.run());\r\n        flash.play();\r\n    }\r\n\r\n\r\n    // Sprite and Platform Factory Methods\r\n    private static ImageView createHeroSprite(Hero hero) {\r\n        ImageView sprite = new ImageView();\r\n        sprite.getStyleClass().add(\"hero-sprite\");\r\n        try {\r\n            String spritePath = getHeroSpritePath(hero);\r\n            Image heroImage = new Image(Objects.requireNonNull(CombatScreen.class.getResourceAsStream(spritePath)));\r\n            sprite.setImage(heroImage);\r\n        } catch (Exception e) {\r\n            System.err.println(\"Could not load hero sprite, using fallback\");\r\n            sprite.setStyle(\"-fx-background-color: steelblue; -fx-background-radius: 10px;\");\r\n        }\r\n\r\n        return sprite;\r\n    }\r\n\r\n    private static ImageView createMonsterSprite(Monster monster) {\r\n        ImageView sprite = new ImageView();\r\n        sprite.getStyleClass().add(\"monster-sprite\");\r\n        try {\r\n            String spritePath = getMonsterSpritePath(monster);\r\n            Image monsterImage = new Image(Objects.requireNonNull(CombatScreen.class.getResourceAsStream(spritePath)));\r\n            sprite.setImage(monsterImage);\r\n        } catch (Exception e) {\r\n            System.err.println(\"Could not load monster sprite, using fallback\");\r\n            sprite.setStyle(\"-fx-background-color: darkred; -fx-background-radius: 10px;\");\r\n        }\r\n\r\n        return sprite;\r\n    }\r\n\r\n    private static String getHeroSpritePath(Hero hero) {\r\n        if (hero == null) return \"/sprites/heroes/default.png\";\r\n\r\n        return switch (hero.getType()) {\r\n            case WARRIOR -> \"/sprites/heroes/warrior.png\";\r\n            case PRIESTESS -> \"/sprites/heroes/priestess.png\";\r\n            case THIEF -> \"/sprites/heroes/thief.png\";\r\n        };\r\n    }\r\n\r\n    private static String getMonsterSpritePath(Monster monster) {\r\n        if (monster == null) return \"/sprites/monsters/default.png\";\r\n\r\n        return \"/sprites/monsters/\" +\r\n                monster.getType().getName().toLowerCase().replace(\" \", \"_\") + \".png\";\r\n    }\r\n\r\n    private static Group createPlatform(double centerX, double centerY, double radiusX, double radiusY) {\r\n        Group platformGroup = new Group();\r\n\r\n        Ellipse baseEllipse = new Ellipse(centerX, centerY, radiusX, radiusY);\r\n        baseEllipse.setFill(Color.rgb(150, 150, 220, 0.3));\r\n        baseEllipse.setStroke(Color.rgb(200, 200, 255, 0.7));\r\n        baseEllipse.setStrokeWidth(2);\r\n\r\n        Bloom bloomEffect = new Bloom();\r\n        bloomEffect.setThreshold(0.6);\r\n        baseEllipse.setEffect(bloomEffect);\r\n\r\n        Ellipse innerAccent = new Ellipse(centerX, centerY, radiusX * 0.7, radiusY * 0.7);\r\n        innerAccent.setFill(Color.TRANSPARENT);\r\n        innerAccent.setStroke(Color.rgb(200, 200, 255, 0.4));\r\n        innerAccent.setStrokeWidth(1.5);\r\n        innerAccent.getStrokeDashArray().addAll(5d, 5d);\r\n\r\n        platformGroup.getChildren().addAll(baseEllipse, innerAccent);\r\n        return platformGroup;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Program/src/main/View/screen/CombatScreen.java b/Program/src/main/View/screen/CombatScreen.java
--- a/Program/src/main/View/screen/CombatScreen.java	(revision 39c706f74afc93f3ab4b296fbadd46285dd6f2c0)
+++ b/Program/src/main/View/screen/CombatScreen.java	(date 1749691756913)
@@ -89,6 +89,7 @@
     private ProgressBar heroHealthBar;
     private ProgressBar monsterHealthBar;
     private Label heroHealthNumbers;
+    private Label heroManaNumbers;
     private Label monsterHealthNumbers;
     private Text heroNameDisplay;
     private Text monsterNameDisplay;
@@ -355,8 +356,9 @@
 
         VBox nameSection = createNameSection(true);
         VBox healthSection = createHealthSection(true);
+        VBox manaSection = createManaSection(true);
 
-        heroInfo.getChildren().addAll(nameSection, healthSection);
+        heroInfo.getChildren().addAll(nameSection, healthSection, manaSection);
         return heroInfo;
     }
 
@@ -452,6 +454,14 @@
             heroHealthBar = healthBar;
             heroHealthNumbers = healthNumbers;
             updateHeroHealthDisplay();
+
+            // Create and store mana display
+            heroManaNumbers = new Label();
+            heroManaNumbers.getStyleClass().add("combat-subtitle");
+            heroManaNumbers.fontProperty().bind(Bindings.createObjectBinding(() ->
+                            Font.font("PixelFont", subtitleFontSizeBinding.getValue().doubleValue()),
+                    subtitleFontSizeBinding));
+            updateHeroManaDisplay(heroManaNumbers);
         } else {
             monsterHealthBar = healthBar;
             monsterHealthNumbers = healthNumbers;
@@ -462,6 +472,34 @@
         return healthSection;
     }
 
+    private VBox createManaSection(boolean isHero) {
+        if (!isHero) {
+            return null; // Only heroes have mana, monsters don't
+        }
+
+        VBox manaSection = new VBox();
+        manaSection.setAlignment(Pos.CENTER_LEFT);
+        manaSection.spacingProperty().bind(spacingBinding.divide(6));
+
+        Label manaLabel = new Label("MANA");
+        manaLabel.getStyleClass().add("combat-subtitle");
+        manaLabel.fontProperty().bind(Bindings.createObjectBinding(() ->
+                        Font.font("PixelFont", subtitleFontSizeBinding.getValue().doubleValue()),
+                subtitleFontSizeBinding));
+
+        if (heroManaNumbers == null) {
+            heroManaNumbers = new Label();
+            heroManaNumbers.getStyleClass().add("combat-subtitle");
+            heroManaNumbers.fontProperty().bind(Bindings.createObjectBinding(() ->
+                            Font.font("PixelFont", subtitleFontSizeBinding.getValue().doubleValue()),
+                    subtitleFontSizeBinding));
+            updateHeroManaDisplay(heroManaNumbers);
+        }
+
+        manaSection.getChildren().addAll(manaLabel, heroManaNumbers);
+        return manaSection;
+    }
+
     private ProgressBar createHealthBar() {
         ProgressBar healthBar = new ProgressBar();
         healthBar.getStyleClass().add("progress-bar");
@@ -633,6 +671,7 @@
         if (currentHero != null) {
             heroNameDisplay.setText(currentHero.getName());
             updateHeroHealthDisplay();
+            updateHeroManaDisplay(heroManaNumbers);
         }
 
         if (currentMonster != null) {
@@ -677,6 +716,12 @@
         }
     }
 
+    private void updateHeroManaDisplay(Label manaNumbers) {
+        if (currentHero != null && manaNumbers != null) {
+            manaNumbers.setText(currentHero.getSpecialMana() + "/4");
+        }
+    }
+
     private void updateMonsterHealthDisplay() {
         if (currentMonster != null && monsterHealthNumbers != null) {
             monsterHealthNumbers.setText(currentMonster.getHealthDisplay());
Index: Program/src/main/Model/character/Hero.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main.Model.character;\r\n\r\nimport java.util.*;\r\n\r\nimport main.Model.dungeon.Room;\r\nimport main.Model.element.HealthPotion;\r\nimport main.Model.element.Item;\r\nimport main.Model.element.Pillar;\r\nimport main.Model.util.HeroType;\r\nimport javafx.scene.image.Image;\r\n\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.fasterxml.jackson.core.JsonProcessingException;\r\nimport main.Model.util.Point;\r\n\r\n/**\r\n * Represents the player character.\r\n * This class extends Character and includes hero-specific attributes like inventory,\r\n * hero type, and interaction with game elements.\r\n */\r\npublic class Hero extends Character {\r\n\r\n    // Constants\r\n    private static final int MAX_INVENTORY_SIZE = 10;\r\n    private static final int TOTAL_PILLARS = 4;\r\n    private static final double BASE_CANVAS_SIZE = 480.0;\r\n    private static final double BASE_MOVEMENT_SPEED = 2.0;\r\n    public static final int SPRITE_FRAME_WIDTH = 232;\r\n    public static final int SPRITE_FRAME_HEIGHT = 212;\r\n\r\n    // Core hero attributes\r\n    private final HeroType myHeroType;\r\n    private final ArrayList<Item> myInventory;\r\n    private int myPillarsActivated;\r\n    private int myGold;\r\n    private int mySpecialMana = 2;\r\n    private boolean myBossSlain = false;\r\n\r\n    private boolean myManaBuff = false;\r\n    private int myAttackBuff = 0;\r\n\r\n    // Movement and positioning\r\n    private double myPixelX;\r\n    private double myPixelY;\r\n    private final MovementState myMovementState;\r\n    private double myMovementSpeed = BASE_MOVEMENT_SPEED;\r\n\r\n    // Animation\r\n    private transient Image mySpriteSheet;\r\n    private final AnimationState myAnimationState;\r\n    private transient Image mySprite;\r\n\r\n    public Hero(final HeroBuilder theHeroBuilder) {\r\n        super(theHeroBuilder);\r\n        this.myHeroType = theHeroBuilder.myHeroType;\r\n        this.myInventory = new ArrayList<>();\r\n        this.myPillarsActivated = 0;\r\n        this.myGold = 0;\r\n        this.myMovementState = new MovementState();\r\n        this.myAnimationState = new AnimationState();\r\n        loadSpriteSheet();\r\n    }\r\n\r\n\r\n\r\n    private void loadSpriteSheet() {\r\n        try {\r\n            String spritePath = getSpritePathForHeroType();\r\n            mySpriteSheet = new Image(Objects.requireNonNull(\r\n                    getClass().getResourceAsStream(spritePath)));\r\n        } catch (Exception e) {\r\n            System.err.println(\"Error loading hero sprite sheet: \" + e.getMessage());\r\n            mySpriteSheet = null;\r\n        }\r\n    }\r\n\r\n    private String getSpritePathForHeroType() {\r\n        return switch (myHeroType) {\r\n            case THIEF -> \"/sprites/heroes/thief_walk_spritesheet.png\";\r\n            case WARRIOR -> \"/sprites/heroes/warrior_walk_spritesheet.png\";\r\n            case PRIESTESS -> \"/sprites/heroes/priestess_walk_spritesheet.png\";\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Performs an attack on a target character.\r\n     * Damage calculation can be based on hero's type, equipped items, and other factors.\r\n     *\r\n     * @param theTarget The Character to attack.\r\n     * @return The amount of damage dealt.\r\n     */\r\n    @Override\r\n    public int attack(final Character theTarget) {\r\n        if(theTarget == null || !theTarget.isAlive()) {\r\n            return 0;//Cannot attack null or dead target\r\n        }\r\n\r\n        //Base damage from HeroType\r\n        int damageDealt = myHeroType.getBaseAttack() + myAttackBuff;\r\n\r\n        Random rand = new Random();\r\n        if(rand.nextDouble(1) < getCritChance()){\r\n            damageDealt *= getCritMultiplier();\r\n            System.out.println(\"Crit landed\");\r\n        }\r\n\r\n        System.out.println(getName()+ \"attacks\" + ((theTarget instanceof Monster) ?\r\n                ((Monster)theTarget).getName():\"target\") + \"for\" + damageDealt + \"damage.\");\r\n\r\n        theTarget.takeDamage(damageDealt);\r\n        if(!theTarget.isAlive() && theTarget instanceof Monster) {\r\n            addGold(((Monster)theTarget).getGoldReward());\r\n            addMana();\r\n            if (((Monster) theTarget).getType().isBoss()) {\r\n                myBossSlain = true;\r\n            }\r\n        }\r\n        return damageDealt;\r\n    }\r\n\r\n    private String getTargetName(Character target) {\r\n        return (target instanceof Monster monster) ? monster.getName() : \"target\";\r\n    }\r\n\r\n    public void useItem(final Item theItem) {\r\n        if (theItem == null || !myInventory.contains(theItem)) {\r\n            if (theItem != null) {\r\n                System.out.println(getName() + \" tried to use \" + theItem.getName() +\r\n                        \" but it's not in inventory.\");\r\n            }\r\n            return;\r\n        }\r\n\r\n        System.out.println(getName() + \" uses \" + theItem.getName() + \".\");\r\n        theItem.use(this);\r\n        myInventory.remove(theItem);\r\n    }\r\n\r\n    public boolean pickupItem(final Item theItem) {\r\n        if (theItem == null) {\r\n            return false;\r\n        }\r\n\r\n        if (myInventory.size() >= MAX_INVENTORY_SIZE) {\r\n            System.out.println(getName() + \"'s inventory is full. Cannot pick up \" +\r\n                    theItem.getName() + \".\");\r\n            return false;\r\n        }\r\n\r\n        myInventory.add(theItem);\r\n\r\n        System.out.println(getName() + \" picked up \" + theItem.getName() + \".\");\r\n        return true;\r\n    }\r\n\r\n    public boolean activatePillar(final Pillar thePillar) {\r\n        if (thePillar == null || thePillar.isActivated()) {\r\n            return false;\r\n        }\r\n        thePillar.activate(this);\r\n        return true;\r\n    }\r\n\r\n    public boolean hasActivatedAllPillars() {\r\n        return myPillarsActivated >= TOTAL_PILLARS;\r\n    }\r\n\r\n    public int specialAttack() {\r\n        int baseDamage = myHeroType.getSpecialAttackDamage();\r\n        // Stat bonuses from pillars\r\n        int totalDamage = baseDamage + myAttackBuff;\r\n\r\n        Random rand = new Random();\r\n        if(rand.nextDouble(1) < getCritChance()){\r\n            totalDamage *= getCritMultiplier();\r\n            System.out.println(\"Critlanded\");\r\n        }\r\n\r\n        System.out.println(getName() + \" performs a special attack!\");\r\n        if (myManaBuff) {\r\n            mySpecialMana--;\r\n            System.out.println(\"Mana at: \" + mySpecialMana + \"/4\");\r\n        } else {\r\n            mySpecialMana -= 2;\r\n            System.out.println(\"Mana at: \" + mySpecialMana + \"/4\");\r\n        }\r\n        return totalDamage;\r\n    }\r\n\r\n    public boolean canUseSpecialAttack() {\r\n        boolean canUse = false;\r\n        if (myManaBuff) {\r\n            canUse = mySpecialMana >= 1;\r\n        } else {\r\n            canUse = mySpecialMana >= 2;\r\n        }\r\n        return canUse;\r\n    }\r\n\r\n    public void addMana() {\r\n        if (mySpecialMana < 4){\r\n            mySpecialMana++;\r\n            System.out.println(\"Mana gained: \" + mySpecialMana + \"/4\");\r\n        } else {\r\n            System.out.println(\"Mana at max: \" + mySpecialMana + \"/4\");\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void takeDamage(final int theDamageAmount) {\r\n        super.takeDamage(theDamageAmount);\r\n        System.out.println(getName() + \" takes \" + theDamageAmount +\r\n                \" damage. Current health: \" + getHealth() + \"/\" + getMaxHealth());\r\n\r\n        if (!isAlive()) {\r\n            System.out.println(getName() + \" has been defeated!\");\r\n        }\r\n    }\r\n\r\n    public void addGold(final int theAmount) {\r\n        if (theAmount > 0) {\r\n            this.myGold += theAmount;\r\n            System.out.println(getName() + \" gained \" + theAmount +\r\n                    \" gold. Total: \" + myGold);\r\n        }\r\n    }\r\n\r\n    public boolean spendGold(final int theAmount) {\r\n        if (theAmount <= 0 || this.myGold < theAmount) {\r\n            System.out.println(getName() + \" does not have enough gold to spend \" +\r\n                    theAmount + \".\");\r\n            return false;\r\n        }\r\n\r\n        this.myGold -= theAmount;\r\n        System.out.println(getName() + \" spent \" + theAmount +\r\n                \" gold. Remaining: \" + myGold);\r\n        return true;\r\n    }\r\n\r\n    // Movement methods\r\n    public void setPixelPosition(double x, double y) {\r\n        myPixelX = x;\r\n        myPixelY = y;\r\n    }\r\n\r\n    public void startMovingNorth() { myMovementState.setMovingNorth(true); }\r\n    public void stopMovingNorth() { myMovementState.setMovingNorth(false); }\r\n    public void startMovingSouth() { myMovementState.setMovingSouth(true); }\r\n    public void stopMovingSouth() { myMovementState.setMovingSouth(false); }\r\n    public void startMovingEast() { myMovementState.setMovingEast(true); }\r\n    public void stopMovingEast() { myMovementState.setMovingEast(false); }\r\n    public void startMovingWest() { myMovementState.setMovingWest(true); }\r\n    public void stopMovingWest() { myMovementState.setMovingWest(false); }\r\n\r\n    public void setMovementSpeedForCanvasSize(double canvasSize) {\r\n        double speedScale = canvasSize / BASE_CANVAS_SIZE;\r\n        myMovementSpeed = BASE_MOVEMENT_SPEED * speedScale;\r\n        myMovementSpeed = Math.max(1.0, Math.min(myMovementSpeed, 8.0));\r\n    }\r\n\r\n    public void updatePixelPosition() {\r\n        if (myMovementState.isMovingNorth()) myPixelY -= myMovementSpeed;\r\n        if (myMovementState.isMovingSouth()) myPixelY += myMovementSpeed;\r\n        if (myMovementState.isMovingEast()) myPixelX += myMovementSpeed;\r\n        if (myMovementState.isMovingWest()) myPixelX -= myMovementSpeed;\r\n    }\r\n\r\n    public boolean isMoving() {\r\n        return myMovementState.isMoving();\r\n    }\r\n\r\n    public void updateAnimation(long currentTimeNanos) {\r\n        myAnimationState.update(currentTimeNanos, isMoving(), myMovementState);\r\n    }\r\n\r\n    // Animation getters\r\n    public Image getSpriteSheet() { return mySpriteSheet; }\r\n    public Image getSprite() { return mySprite; }\r\n    public int getCurrentFrameX() { return myAnimationState.getCurrentFrameX(); }\r\n    public int getAnimationRow() { return myAnimationState.getAnimationRow(); }\r\n\r\n    // Health display methods\r\n    public double getHealthPercentage() {\r\n        return Math.max(0.0, Math.min(1.0, (double) getHealth() / getMaxHealth()));\r\n    }\r\n\r\n    public String getHealthDisplay() {\r\n        return getHealth() + \"/\" + getMaxHealth();\r\n    }\r\n\r\n    // Getters\r\n    public HeroType getType() { return myHeroType; }\r\n    public List<Item> getInventory() { return Collections.unmodifiableList(myInventory); }\r\n    public int getPillarsActivated() { return myPillarsActivated; }\r\n    public int getGold() { return myGold; }\r\n    public double getPixelX() { return myPixelX; }\r\n    public double getPixelY() { return myPixelY; }\r\n\r\n    // Setters\r\n    public void setPillarsActivated(final int thePillarsActivated) {\r\n        this.myPillarsActivated = Math.max(0, thePillarsActivated);\r\n    }\r\n\r\n    public void setManaBuff(final boolean theManaBuff) {\r\n        myManaBuff = theManaBuff;\r\n    }\r\n\r\n    public void addAttackBuff(final int theAttackBuff) {\r\n        myAttackBuff += theAttackBuff;\r\n    }\r\n\r\n    public void addItem(final Item theItem) {\r\n        pickupItem(theItem);\r\n    }\r\n\r\n    public boolean getBossSlain() {\r\n        return myBossSlain;\r\n    }\r\n\r\n    public void setBossSlain(final boolean theBossSlain) {\r\n        myBossSlain = theBossSlain;\r\n    }\r\n\r\n    // Inner classes for better organization\r\n    private static class MovementState {\r\n        private boolean isMovingNorth = false;\r\n        private boolean isMovingSouth = false;\r\n        private boolean isMovingEast = false;\r\n        private boolean isMovingWest = false;\r\n\r\n        public void setMovingNorth(boolean moving) { isMovingNorth = moving; }\r\n        public void setMovingSouth(boolean moving) { isMovingSouth = moving; }\r\n        public void setMovingEast(boolean moving) { isMovingEast = moving; }\r\n        public void setMovingWest(boolean moving) { isMovingWest = moving; }\r\n\r\n        public boolean isMovingNorth() { return isMovingNorth; }\r\n        public boolean isMovingSouth() { return isMovingSouth; }\r\n        public boolean isMovingEast() { return isMovingEast; }\r\n        public boolean isMovingWest() { return isMovingWest; }\r\n\r\n        public boolean isMoving() {\r\n            return isMovingNorth || isMovingSouth || isMovingEast || isMovingWest;\r\n        }\r\n    }\r\n\r\n    private static class AnimationState {\r\n        private static final int TOTAL_FRAMES_PER_DIRECTION = 3;\r\n        private static final long FRAME_DURATION_MILLIS = 150;\r\n\r\n        private int currentFrameX = 0;\r\n        private int animationRow = 0;\r\n        private long lastFrameTime = 0;\r\n\r\n        public void update(long currentTimeNanos, boolean isMoving, MovementState movementState) {\r\n            if (lastFrameTime == 0) {\r\n                lastFrameTime = currentTimeNanos;\r\n            }\r\n\r\n            if (!isMoving) {\r\n                currentFrameX = 1; // Idle frame\r\n                return;\r\n            }\r\n\r\n            long elapsedTimeMillis = (currentTimeNanos - lastFrameTime) / 1_000_000;\r\n            if (elapsedTimeMillis > FRAME_DURATION_MILLIS) {\r\n                lastFrameTime = currentTimeNanos;\r\n                currentFrameX = (currentFrameX + 1) % TOTAL_FRAMES_PER_DIRECTION;\r\n            }\r\n\r\n            updateAnimationRow(movementState);\r\n        }\r\n\r\n        private void updateAnimationRow(MovementState movementState) {\r\n            if (movementState.isMovingNorth()) {\r\n                animationRow = 2;\r\n            } else if (movementState.isMovingSouth()) {\r\n                animationRow = 0;\r\n            } else if (movementState.isMovingWest()) {\r\n                animationRow = 3;\r\n            } else if (movementState.isMovingEast()) {\r\n                animationRow = 1;\r\n            }\r\n        }\r\n\r\n        public int getCurrentFrameX() { return currentFrameX; }\r\n        public int getAnimationRow() { return animationRow; }\r\n    }\r\n\r\n    public static class HeroBuilder extends CharacterBuilder<HeroBuilder, Hero> {\r\n        private HeroType myHeroType;\r\n\r\n        public HeroBuilder setHeroType(final HeroType theHeroType) {\r\n            myHeroType = theHeroType;\r\n            return self();\r\n        }\r\n\r\n        @Override\r\n        protected HeroBuilder self() {\r\n            return this;\r\n        }\r\n\r\n        @Override\r\n        public Hero build() {\r\n            return new Hero(this);\r\n        }\r\n    }\r\n\r\n    // SERIALIZATION  METHODS //\r\n\r\n    /**\r\n     * Serializes hero to JSON format for saving.\r\n     * Converts hero's state including personal data, stats, inventory,\r\n     * position, and progress into JSON string that can be stored in database\r\n     * inventory items are serialized by name and will need to be recreated during loading\r\n     *\r\n     * @return JSON string representation of hero's state, or null if serialization fails\r\n     */\r\n    public String toJson() {\r\n        try {\r\n            ObjectMapper mapper = new ObjectMapper();\r\n            HeroSaveData saveData = new HeroSaveData();\r\n            saveData.name = getName();\r\n            saveData.heroType = myHeroType.name();\r\n            saveData.health = getHealth();\r\n            saveData.maxHealth = getMaxHealth();\r\n            saveData.attackBuff = myAttackBuff; // You were going to fix up factory for hero to add these things\r\n            saveData.specialMana = mySpecialMana;\r\n            saveData.manaBuff = myManaBuff;\r\n            saveData.gold = myGold;\r\n            saveData.pillarsActivated = myPillarsActivated;\r\n            saveData.positionX = getPosition().getX();\r\n            saveData.positionY = getPosition().getY();\r\n            saveData.pixelX = myPixelX;\r\n            saveData.pixelY = myPixelY;\r\n\r\n            //serialize inventory\r\n            saveData.inventoryItems = new ArrayList<>();\r\n            for (Item item : myInventory) {\r\n                saveData.inventoryItems.add(item.getName());\r\n            }\r\n\r\n            return mapper.writeValueAsString(saveData);\r\n        } catch (JsonProcessingException e) {\r\n            System.err.println(\"Error serializing hero: \" + e.getMessage());\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deserializes a hero from JSON format\r\n     * Creates a new Hero instance from saved JSON data, restoring all hero state\r\n     * including name, type, health, position, gold, pillar progress, and inventory\r\n     *\r\n     * @param json JSON string containing serialized hero data\r\n     * @return new Hero instance restored from JSON data, or null if deserialization fails\r\n     */\r\n    public static Hero fromJson(String json) {\r\n        try {\r\n            ObjectMapper mapper = new ObjectMapper();\r\n            HeroSaveData saveData = mapper.readValue(json, HeroSaveData.class);\r\n\r\n            HeroType heroType = HeroType.valueOf(saveData.heroType);\r\n            Hero hero = new HeroBuilder()\r\n                    .setName(saveData.name)\r\n                    .setHeroType(heroType)\r\n                    .setHealth(saveData.health)\r\n                    .setMaxHealth(saveData.maxHealth)\r\n                    .setPosition(new Point(saveData.positionX, saveData.positionY))\r\n                    .build();\r\n\r\n            // Restore all the saved data\r\n            hero.myGold = saveData.gold;\r\n            hero.myPillarsActivated = saveData.pillarsActivated;\r\n\r\n            // CRITICAL: Restore pixel position\r\n            hero.myPixelX = saveData.pixelX;\r\n            hero.myPixelY = saveData.pixelY;\r\n            hero.myAttackBuff = saveData.attackBuff;\r\n            hero.mySpecialMana = saveData.specialMana;\r\n            hero.myManaBuff = saveData.manaBuff;\r\n\r\n            // CRITICAL: Reset movement state to ensure clean state\r\n            hero.myMovementState.setMovingNorth(false);\r\n            hero.myMovementState.setMovingSouth(false);\r\n            hero.myMovementState.setMovingEast(false);\r\n            hero.myMovementState.setMovingWest(false);\r\n\r\n            // Restore inventory\r\n            for (String itemName : saveData.inventoryItems) {\r\n                hero.addItem(new HealthPotion(\"Health Potion\", \"Heals 50\", 50));\r\n            }\r\n\r\n            // CRITICAL: Reload sprite sheet since it's transient\r\n            hero.loadSpriteSheet();\r\n\r\n            System.out.println(\"Hero loaded - Position: \" + hero.getPosition() +\r\n                              \", Pixel: (\" + hero.myPixelX + \",\" + hero.myPixelY + \")\");\r\n\r\n            return hero;\r\n        } catch (Exception e) {\r\n            System.err.println(\"Error deserializing hero: \" + e.getMessage());\r\n            e.printStackTrace();\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // inner class for save data\r\n    private static class HeroSaveData {\r\n        public String name;\r\n        public String heroType;\r\n        public int health;\r\n        public int maxHealth;\r\n        public int attackBuff;\r\n        public int specialMana;\r\n        public boolean manaBuff;\r\n        public int gold;\r\n        public int pillarsActivated;\r\n        public int positionX;\r\n        public int positionY;\r\n        public double pixelX;\r\n        public double pixelY;\r\n        public List<String> inventoryItems;\r\n    }\r\n\r\n    /**\r\n     * synchronizes pixel position with room position\r\n     * Call this after loading to ensure pixel and room positions match\r\n     */\r\n    public void synchronizePositions(double roomPixelWidth, double roomPixelHeight) {\r\n        Point roomPos = getPosition();\r\n        myPixelX = roomPos.getX() * roomPixelWidth + (roomPixelWidth / 2);\r\n        myPixelY = roomPos.getY() * roomPixelHeight + (roomPixelHeight / 2);\r\n\r\n        System.out.println(\"Synchronized positions - Room: \" + roomPos +\r\n                          \", Pixel: (\" + myPixelX + \",\" + myPixelY + \")\");\r\n    }\r\n\r\n    /**\r\n     *reset all movement flags to ensure clean state\r\n     */\r\n    public void resetMovementState() {\r\n        myMovementState.setMovingNorth(false);\r\n        myMovementState.setMovingSouth(false);\r\n        myMovementState.setMovingEast(false);\r\n        myMovementState.setMovingWest(false);\r\n        System.out.println(\"Movement state reset\");\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Program/src/main/Model/character/Hero.java b/Program/src/main/Model/character/Hero.java
--- a/Program/src/main/Model/character/Hero.java	(revision 39c706f74afc93f3ab4b296fbadd46285dd6f2c0)
+++ b/Program/src/main/Model/character/Hero.java	(date 1749690042244)
@@ -289,6 +289,10 @@
         return getHealth() + "/" + getMaxHealth();
     }
 
+    public int getSpecialMana() {
+        return mySpecialMana;
+    }
+
     // Getters
     public HeroType getType() { return myHeroType; }
     public List<Item> getInventory() { return Collections.unmodifiableList(myInventory); }
